"""
Gather required functions and resources required
for LDAP, DB, token, and HTTP authorization requests.
"""

from flask import session, request, escape
from functools import wraps
from log import log_error

import ldap
import ldapwrap
import app
import models
import error

import datetime
import uuid
import hashlib


def auth_ldap_groups(uid, password):
    """
    Return a set of the ldap groups user [uid] is authorized to access.

    :param uid: a valid LDAP uid, e.g. kevin.schaich
    :type uid: string
    :param password: the password corresponding to uid
    :type password: string
    """

    try:
        bind = ldapwrap.LdapWrap(uid, password)
        groups = bind.get_groups()
        bind.close()
        return groups
    except ldap.INVALID_CREDENTIALS:
        log_error("User entered invalid LDAP credentials")
        return False


def get_user_ldap_groups(uid):
    """
    Return a set of the ldap groups user [uid]
    (already in user DB) is authorized to access.

    :param uid: a valid LDAP uid, e.g. kevin.schaich
    :type uid: string
    :param password: the password corresponding to uid
    :type password: string
    """

    query = models.Group.query.\
        filter(models.Group.uid == uid).\
        with_entities(models.Group.group).all()
    user_groups = set(group[0] for group in query)
    return user_groups


def get_access_groups(user_groups):
    """
    Return a set of all access groups
    corresponding to user_groups in the Access table.

    :param user_groups: a valid set of LDAP groups, e.g. set(['inf.interns'])
    :type user_groups: string set
    """

    access_groups = set()

    for group in user_groups:
        query = models.Access.query.\
            filter(models.Access.ldap_group == group).\
            with_entities(models.Access.access_group).all()
        access_groups |= set(group[0] for group in query)

    return access_groups


def add_user(uid, password):
    """
    Generate a hashed security token for user [uid],
    add the token to a session variable on the client-side,
    and add them to the users database on the server.

    Tokens are generated by generating random UUID salt,
    and then combining that with the username, password
    and timestamp. This is then hashed via SHA512.

    :param uid: a valid LDAP uid, e.g. 'kevin.schaich'
    :type uid: string
    :param password: the password corresponding to uid
    :type password: string
    """

    remove_user(uid)

    salt = uuid.uuid4().hex
    timestamp = str(datetime.datetime.now())
    token = salt + uid + password + timestamp
    hashed = hashlib.sha512(token).hexdigest()

    user = models.User(uid, hashed)
    app.db_session.add(user)
    app.db_session.commit()
    session['token'] = hashed
    session['user'] = uid


def remove_user(uid):
    """
    Remove the token corresponding to user [uid]
    from the session variable on the client-side,
    as well as the entry in the users database.

    :param uid: a valid LDAP uid, e.g. kevin.schaich
    :type uid: string
    """

    session.pop('token', None)
    session.pop('user', None)

    user = models.User.query.filter(models.User.uid == uid).first()

    models.Group.query.filter(models.Group.uid == uid).delete()

    if user is not None:
        app.db_session.delete(user)
        app.db_session.commit()


def add_user_groups(uid, user_groups):
    """
    Add access to all user_groups in [user_groups] for user [uid]
    in the database.

    :param uid: a valid LDAP uid, e.g. kevin.schaich
    :type uid: string
    :param user_groups: user_groups a user is a member of
    :type user_groups: string list
    """

    if not user_groups:
        pass
    else:
        for item in user_groups:
            group = models.Group(uid, item)
            app.db_session.add(group)
        app.db_session.commit()


def get_db_token(token):
    """
    Return whether or not token [token] is in the user database.

    :param token: a hashed security token used for user authentication
    :type token: string
    """

    db_token = models.User.query.filter(models.User.token == token).first()
    if not db_token:
        return False
    else:
        return db_token


def valid_token():
    """
    Return whether a user has a valid token.

    Validate their client-side token with the DB, checking
    for both presence on both sides as well as a valid timestamp.
    """

    try:
        token = escape(session['token'])
        db_token = get_db_token(token)
        if db_token:
            timestamp = db_token.timestamp
            now = datetime.datetime.now()
            delta = now - timestamp
            return delta.days == 0 and delta.seconds <= 7200
    except KeyError:
        return False


def has_access(required_access_groups):
    """
    Return if the intersection of [required_access_groups] and
    user_groups have at least one common element.

    A user is allowed to access a page if they are a
    member of at least one of the required access groups.

    :param required_access_groups: required_access_groups required
        to access a specific page
    :type required_access_groups: string list
    """
    try:
        token = escape(session['token'])

        uid = models.User.query.filter(
            models.User.token == token).first().uid

        user_groups = get_user_ldap_groups(uid)
        access_groups = get_access_groups(user_groups)
        in_common = required_access_groups & access_groups
        return len(in_common) > 0

    except KeyError:
        return False


def authenticate():
    """
    Authenticate a user who does not currently have a valid token.

    If they are authorized to access any of the groups in
    [required_access_groups], add them to the database and
    return an access token as a cookie.

    If authentication fails, authenticate() will abort the request
    and raise an Unauthorized exception.
    """

    if not request.method == 'POST':
        log_error("User attempted to view a page without authentication.")
        raise error.Unauthorized
    else:
        uid = request.form.get('uid')
        password = request.form.get('password')
        if not uid or not password:
            log_error("No user login credentials were entered.")
            raise error.Unauthorized
        else:
            user_groups = auth_ldap_groups(uid, password)
            if not user_groups:
                log_error("Entered user login credentials were invalid.")
                raise error.Unauthorized
            else:
                add_user(uid, password)
                add_user_groups(uid, user_groups)


def requires_groups(*required_access_groups):
    """
    Decorator function to restrict a page's access to employees
    who are a member of one of the access groups in [required_access_groups].

    If they are not authorized to access any of the groups,
    authenticate() will abort the request and raise a Forbidden exception.

    :param required_access_groups: groups required to access a specific page
    :type required_access_groups: string list
    """

    def wrapper(f):
        """Wrapper function for requires_groups"""
        @wraps(f)
        def wrapped(*args, **kwargs):
            """Wrapper function for requires_groups"""
            if not valid_token():
                authenticate()
            if not has_access(set(required_access_groups)):
                raise error.Forbidden
            return f(*args, **kwargs)
        return wrapped
    return wrapper
